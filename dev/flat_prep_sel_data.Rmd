---
title: "flat_prep_sel_data.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

In the ‘inser’ package, selectivity data can be obtained from three types of experimental protocols onboard fishing vessels: 'twin', 'single paired' or 'independent' sampling, for which a test fishing gear is compared to a standard fishing gear.

<div align="center">**Acronyms**</div>

STD: stands for the standard fishing gear usually used, it is the reference gear 

TEST: stands for the gear modified with a new selective device to be tested

LAN: Fraction of the catch retained by the fisherman (= Landings)

DIS: Part of the catch not retained by the fisherman (= Discards)

FO: Fishing Operation

## 1) Data Collection Protocol

For the two paired protocol types (twin or paired-single hauls), the environmental (depth, type of bottom) and fishing (duration, speed, heading/current, characteristics of the gear apart from the tested device) conditions, as well as the available fished population are assumed to be equivalent between the two FOs of each pair.

### Twin' gear protocol
Some fishing gears allow the simultaneous comparison of a gear equipped with a selective device with a standard one during the same fishing trip.

This is typically the case for a twin trawl, where the STD and TEST gear can be rigged simultaneously (the catches of two sub-gears will be compared as if they were two separate gears). This configuration can also be transposed to nets, lines, or pots gear deployed from a single vessel. 

The 'twin' configuration is ideal as the variability of fishing conditions between the two gears is limited, as the two gears STD and TEST are paired within each FO (1 pair = 1 FO).

### Single paired' protocol

In the case of the single trawl, it is possible to implement a protocol where the FOs are paired: FOs are paired as STD/TEST when they take place under conditions considered similar (i.e. similar target species, depth, gear speed, orientation to the current and fishing duration). For example, STD and TEST FOs can be alternated so that two FOs close together in time and space (but not exactly at the same location) are matched to form a pair.

### Independent' protocol

The least restrictive protocol when the gear does not allow a 'matched' protocol is to conduct two sets of FOs (STD and TEST) independently. The available fishery resource, environmental and fishing conditions should nevertheless be similar, but only at the scale of the two sets of FOs. This protocol is subject to more uncertainties and will require more FOs to achieve the same accuracy as a paired protocol.

### On-board catch sampling protocol

Catch sampling is carried out by an observer on board a professional fishing vessel. Whether it is a twin trawl or a single trawl operation (alternating or parallel), the catch sampling method is the same. For each trawl, the discarded and landed fractions must be processed, and at least the total catch weight (discards + landings) must be recorded. 

These selectivity experiments may focus on one or a few problematic species and not necessarily on all species caught. In this case, the catch sampling protocol focuses on a selection of species of interest (in addition to the total catch weight in each trawl).
The catch sampling methodology consists of (Figure 1) : 

- estimate the total quantity of the discarded fraction of a gear [1]. This quantity can be estimated by weighing only a part of the discard (e.g. a basket), assuming that the density of this sample is representative of the whole discarded fraction.

- Collect, weigh and sort a 'bulk' sample of the discard [2]. The 'bulk' sample consists of a mixture of species representative of the discarded fraction. The ratio taken is recorded (1/n) [3]. 

- Weigh the species of interest separately from the bulk sample [4] and measure the individuals [5]. (NB: if individuals of a species are measured, they must be measured for both fractions (landed and discarded) in order to describe a complete catch profile (same for weighing: the weight of a discarded species must be associated with the weight of the landed species if applicable). If a subsample per species is required, the ratio taken is recorded (1/m) [6].

- record the weights by species of the landed fraction [7]. For each species of interest, a sample of individuals is measured [8] and its weight recorded [9]. If it is not possible to weigh the samples on board, a conversion to weight can be made later on land from the available length-weight relationships.

- Individuals present in very small quantities and easily identifiable can be considered as "non-bulk". In this case, all individuals are extracted from the catch and are not subject to the same sampling rules as those described for the "bulk" sample: all individuals are weighed and measured and a sampling coefficient of 1:1 is applied to them [10].

- Once the species in the bulk sample have been sorted, individuals of the species of interest are measured. The minimum size of the measured samples is assessed by the observer; the objective being to be able to describe the length distribution of the captured species. If a small length range is observed for a species, the distribution will stabilize fairly quickly and a small number of individuals (minimum 30) will be required. The sample size will be increased if a large length range is observed.


```{r fig1, echo = FALSE, out.width="95%", fig.cap="Figure 1 : Catch sampling protocol (landed fraction and discarded fraction). The same procedure is implemented separately for the STD trawl and for the TEST trawl"}
knitr::include_graphics(path = here::here("vignettes","figure","catch_sampling_protocol.png"))
```

## 2) Data format

The input data format is banked in the form of 4 data tables based on the [ICES RDB data exchange format](https://www.ices.dk/data/Documents/RDB/RDB%20Exchange%20Format.pdf) and corresponding to the different scales of the data.

### TR table

The TR table contains information relating to the fishing trip and the two compared gears.

```{r tr, echo = FALSE}
readr::read_csv(file = here::here("vignettes","table","descriptif_tables-TR.csv"),
                show_col_types = FALSE) %>%
  knitr::kable()
```

### HH table

The HH table contains information relating to the FO for each gear. For twin gears, both gears are deployed at each FO, so there are two different lines for each FO, while for single gears, there is one line for each FO (as only one gear is deployed at each FO).

```{r hh, echo = FALSE}
readr::read_csv(file = here::here("vignettes","table","descriptif_tables-HH.csv"),
                show_col_types = FALSE) %>%
  knitr::kable()
```

### SL table

The SL table contains information relating to the weight of the studies species, for the strata FO x species x catch category (and eventually x landing category x commercial size category x subsampling category x sex).

```{r sl, echo = FALSE}
readr::read_csv(file = here::here("vignettes","table","descriptif_tables-SL.csv"),
                show_col_types = FALSE) %>%
  knitr::kable()
```

### HL table

The HL table contains information relating to the size of individuals of the species studied, within the strata recorded in HL.

```{r hl, echo = FALSE}
readr::read_csv(file = here::here("vignettes","table","descriptif_tables-HL.csv"),
                show_col_types = FALSE) %>%
  knitr::kable()
```


## 3) Prepare Selectivity Data

The function `prep_sel_data()` transforms and prepare the database in order to compute the indices of the create_selectivity_sheet() function.

```{r function-prep_sel_data}
#' prep_sel_data
#' 
#' @description
#' Transform and prepare the database in order to compute the indices of the create_selectivity_sheet() function.
#' 
#' Inputs are catch comparison data obtained from test and standard fishing gear.
#' 
#' Data are recorded under 4 tables:
#' TR table records all information relative to the fishing trial and the gear used;
#' HH table records all information relative to the fishing operation,
#' SL table records all information to the catch weight for each fraction (landings and discards, and eventually landing categories), species (mandatory) and eventually landing category or sex;
#' HL table records number of individuals for each length class.
#' 
#' Not all species are measured and/or weighted, but for a given species, the same level of information is required for each gear and fraction.
#' 
#' The create_selectivity_sheet() function ensures consistency between the 4 tables and allows for filtering on vessel/trial/fishing operation/species to create the summary sheet of the experiment.
#' 
#' The function computes raised numbers of individuals from sampled observed.
#' 
#' @details
#' If the field ‘elevated_number_at_length’ is not provided in HL or some values are missing, the function calculate them using ‘number_at_length’ and the ratio between the subsample_weight and the weight (table SL).
#' 
#' @param data list A list of four data.frames (TR,HH,SL,HL) based on the ICES RDB data exchange format corresponding to each level of the dataset. EU/ICES have defined common format and processing tools, for fisheries statistics.
#' For more details on the input data format, see the related vignette :
#' \code{vignette("selectivity-data", package = "inser")}
#' @param filters list A list of filters to apply on the dataset. The optional filters can apply directly on the fields ‘project’, ‘vessel_identifier’, ‘selective_device’, ‘trip_code’, ‘station_number’. For the fields ‘species_LAN’, ‘species_DIS’, and ‘species_length’, the filter apply on the landings (LAN), discards (DIS) and on the measured species, respectively.
#'
#' @importFrom dplyr filter left_join
#'
#' @return data.frame A data.frame object corresponding to the join of the four tables.
#' @export
prep_sel_data<-function(data,filters=list(project="all",vessel="all",trip="all",station="all",species_LAN="all",species_DIS="all",species_length="all")){

  #Check if data is a list with four data.frames: 
  if(is.list(data)==FALSE)print("data is not a list")#STOP?
  if(length(data)!=4)print("data does not include 4 data.frames")
  TR<-data[[1]] 
  if(is.data.frame(TR)==FALSE)print("data does not include 4 data.frames")
  
  HH<-data[[2]] 
  if(is.data.frame(HH)==FALSE)print("data does not include 4 data.frames")
  
  SL<-data[[3]] 
  if(is.data.frame(SL)==FALSE)print("data does not include 4 data.frames")
  
  HL<-data[[4]]
  if(is.data.frame(HL)==FALSE)print("data does not include 4 data.frames")
  
  ##Filter the 4 tables
  if(filters$project!="all"){
    TR<-filter(TR,project %in% filters$project)
  }
  if(filters$vessel!="all"){
    TR<-filter(TR,vessel_identifier %in% filters$vessel)
  }
  if(filters$trip!="all"){
    TR<-filter(TR,trip_code %in% filters$trip)
  }
  if(filters$station!="all"){
    HH<-filter(HH,station_number %in% filters$station)
  }
  
  if("fishing_validity" %in% names(HH)){
    HH<-filter(HH,fishing_validity != "I")
  }
  
  if(filters$species_LAN!="all"){
    SL[SL$catch_category=="LAN",]<-filter(SL,catch_category=="LAN" & species %in% filters$species_LAN)
  }
  if(filters$species_DIS!="all"){
    SL[SL$catch_category=="DIS",]<-filter(SL,catch_category=="DIS" & species %in% filters$species_DIS)
  }
  if(filters$species_length!="all"){
    HL<-filter(HL,species %in% filters$species_length)
  }
  
  ###Combine the 4 data.frames
  
  #A) TR_HH: trip x Gear x FO 
  key_var<-c("project","vessel_identifier","trip_code","gear_label")
  var_bis<-names(TR)[is.na(match(names(TR),names(HH)))==FALSE]#shared fields
  var_bis<-var_bis[!(var_bis %in% key_var)]
  TR_HH<-left_join(TR,HH,by=key_var)
  
  ##On retire les champs doublons après avoir testé la cohérence des tables
  #Si test = FALSE, il y a des lignes qui n'ont pas le même valeur entre les tables
  if(length(var_bis)>0){
    for(ii in 1:length(var_bis)){
      idX<-which(names(TR_HH)==paste(var_bis[ii],".x",sep=""))
      idY<-which(names(TR_HH)==paste(var_bis[ii],".y",sep=""))
      test<-all(as.character(TR_HH[,idX]) == as.character(TR_HH[,idY]),na.rm=T)
      
      if(test==FALSE){print(paste("Attention probl\u00e8me de valeur dans",var_bis[ii]))}
      if(test==TRUE){
        names(TR_HH)[idX]<-var_bis[ii]
        TR_HH<-TR_HH[,-idY]
      }  
    }
  }
  
  
  #B) TR_HH_SL: trip x Gear x FO x species x fraction x sub-cat x sex 
  key_var<-c("project","vessel_identifier","trip_code","gear_label","station_number")
  var_bis<-names(TR_HH)[is.na(match(names(TR_HH),names(SL)))==FALSE]#shared fields
  var_bis<-var_bis[!(var_bis %in% key_var)]
  TR_HH_SL<-left_join(TR_HH,SL,by=key_var)
  
  ##On retire les champs doublons après avoir testé la cohérence des tables
  #Si test = FALSE, il y a des lignes qui n'ont pas le même valeur entre les tables
  if(length(var_bis)>0){
    for(ii in 1:length(var_bis)){
      idX<-which(names(TR_HH_SL)==paste(var_bis[ii],".x",sep=""))
      idY<-which(names(TR_HH_SL)==paste(var_bis[ii],".y",sep=""))
      test<-all(as.character(TR_HH_SL[,idX]) == as.character(TR_HH_SL[,idY]),na.rm=T)
      
      if(test==FALSE){print(paste("Attention probl\u00e8me de valeur dans",var_bis[ii]))}
      if(test==TRUE){
        names(TR_HH_SL)[idX]<-var_bis[ii]
        TR_HH_SL<-TR_HH_SL[,-idY]
      }  
    }
  }
  
  #Elevate the total weight if not already done? Mandatory for now
  # if(!("weight" %in% names(SL))){
  # 
  #   TR_HH_SL$weight[TR_HH_SL$catch_category=="DIS" & TR_HH_SL$subsampling_category=="H-Vrac"]<-with(filter(TR_HH_SL,catch_category=="DIS" & subsampling_category=="H-Vrac"),sample_weight)#DIS H-VRAC
  #   TR_HH_SL$weight[TR_HH_SL$catch_category=="DIS" & TR_HH_SL$subsampling_category!="H-Vrac"]<-with(filter(TR_HH_SL,catch_category=="DIS" & subsampling_category!="H-Vrac"),sample_weight/coef_discard)#DIS Vrac
  #   TR_HH_SL$weight[TR_HH_SL$catch_category=="LAN"]<-with(filter(TR_HH_SL,catch_category=="LAN"),subsample_weight/coef_subsampling)#LAN
  # }#else{
  #   # idNA<-which(is.na(TR_HH_SL$weight))
    # if(length(idNA)>0){
    #   TR_HH_SL$weight[idNA][]<-with(TR_HH_SL[idNA,],subsample_weight/frac_weight)
    #   TR_HH_SL$weight[idNA]<-with(TR_HH_SL[idNA,],subsample_weight/frac_weight)
    # }
  #}
  
  
  ### C) TR_HH_SL_HL: trip x Gear x FO x species x fraction x sub_cat x lan_cat x com_cat x sex 
  key_var<-c("project","vessel_identifier","trip_code","gear_label","station_number","species","catch_category")
  #Optional key fields: 
  opt_key_id<-match(c("landing_category","commercial_size_category","subsampling_category","sex"),names(HL))
  opt_key_id<-opt_key_id[which(is.na(opt_key_id)==FALSE)]
  
  if(length(opt_key_id)>0){opt_key_var<-names(HL)[opt_key_id]
  key_var<-c(key_var,opt_key_var)
  }
  
  var_bis<-names(TR_HH_SL)[is.na(match(names(TR_HH_SL),names(HL)))==FALSE]#shared fields
  var_bis<-var_bis[!(var_bis %in% key_var)]
  TR_HH_SL_HL<-left_join(TR_HH_SL,HL,by=key_var)
  
  
  ##On retire les champs doublons après avoir testé la cohérence des tables
  #Si test = FALSE, il y a des lignes qui n'ont pas le même valeur entre les tables
  if(length(var_bis)>0){
    for(ii in 1:length(var_bis)){
      idX<-which(names(TR_HH_SL_HL)==paste(var_bis[ii],".x",sep=""))
      idY<-which(names(TR_HH_SL_HL)==paste(var_bis[ii],".y",sep=""))
      test<-all(as.character(TR_HH_SL_HL[,idX]) == as.character(TR_HH_SL_HL[,idY]),na.rm=T)
      
      if(test==FALSE){print(paste("Attention probl\u00e8me de valeur dans",var_bis[ii]))}
      if(test==TRUE){
        names(TR_HH_SL_HL)[idX]<-var_bis[ii]
        TR_HH_SL_HL<-TR_HH_SL_HL[,-idY]
      }  
    }
  }
  
  #Elevate the number at lengths if not provided (no field or NA:
  #Mandatory: elevated_number_at_length in HL or subsample_weight + weight in SL
  
  if(!("elevated_number_at_length" %in% names(HL))){
    TR_HH_SL_HL$coef_subsampling<-TR_HH_SL_HL$subsample_weight/TR_HH_SL_HL$weight
    TR_HH_SL_HL$elevated_number_at_length<-TR_HH_SL_HL$number_at_length/TR_HH_SL_HL$coef_subsampling
  }else{
    idNA<-which(is.na(TR_HH_SL_HL$elevated_number_at_length))
    if(length(idNA)>0){
      TR_HH_SL_HL$coef_subsampling<-TR_HH_SL_HL$subsample_weight/TR_HH_SL_HL$weight
      TR_HH_SL_HL$elevated_number_at_length[idNA]<-(TR_HH_SL_HL$number_at_length/TR_HH_SL_HL$coef_subsampling)[idNA]
    }
  }
  
  ##Add all the optional fields if not already reported
  list<-c("vessel_name","selective_device","departure_date_time","return_date_time","headline_cumulative_length",
          "mesh_gauge_codend_mm","area","statistical_rectangle","pos_start_lat_dec","pos_stop_lat_dec","pos_start_lon_dec","pos_stop_lon_dec",
 "water_depth","start_sorting_date_time","end_sorting_date_time","diurnal_operation","gear_speed","gear_depth",
  "sea_state","wind_force","wind_cardinal_direction", "seabed_features","sub_gear_position", "catch_weight",
  "discard_weight")
  var<-list[which(!(list %in% names(TR_HH_SL_HL)))]
  if(length(var)>0){
    TAB_NA<-as.data.frame(matrix(NA,ncol=length(var),nrow=nrow(TR_HH_SL_HL)))
    names(TAB_NA)<-var
    TR_HH_SL_HL<-data.frame(TR_HH_SL_HL,TAB_NA)
  }
  return(TR_HH_SL_HL)
}

```

```{r examples-prep_sel_data}
### Example for protocol 'twin'

OTT_data_folder <-
  system.file("script_origin", "Data", "Example_OTT",
              package = "inser")

TR <- readr::read_delim(
  file = file.path(OTT_data_folder, "TR.csv"),
  delim = ";",
  escape_double = FALSE,
  locale = readr::locale(encoding = "WINDOWS-1252"),
  trim_ws = TRUE
)

HH <- read.table(
  file.path(OTT_data_folder, "HH.csv"),
  sep = ";",
  header = TRUE,
  encoding = "WINDOWS-1252"
)#,colClasses = colClasses)

SL <- read.table(
  file.path(OTT_data_folder, "SL.csv"),
  sep = ";",
  header = TRUE,
  encoding = "WINDOWS-1252"
)

HL <- read.table(
  file.path(OTT_data_folder, "HL.csv"),
  sep = ";",
  header = TRUE,
  encoding = "WINDOWS-1252"
)

colClasses <- rep(NA, ncol(HH))
colClasses[which(names(HH) == "statistical_rectangle")] <-
  "character"

HH <- read.table(
  file.path(OTT_data_folder, "HH.csv"),
  sep = ";",
  header = TRUE,
  colClasses = colClasses,
  encoding = "WINDOWS-1252"
)

TAB <- prep_sel_data(data = list(TR, HH, SL, HL))
```

```{r tests-prep_sel_data}
test_that("prep_sel_data works", {
  
  # Setup OTT input data
  OTT_data_folder <- system.file("script_origin","Data","Example_OTT", package = "inser")
  
  TR <- readr::read_delim(
    file = file.path(OTT_data_folder, "TR.csv"),
    delim = ";",
    escape_double = FALSE,
    locale = readr::locale(encoding = "WINDOWS-1252"),
    trim_ws = TRUE
  )
  HH<-read.table(file.path(OTT_data_folder, "HH.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")#,colClasses = colClasses)
  SL<-read.table(file.path(OTT_data_folder, "SL.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")
  HL<-read.table(file.path(OTT_data_folder, "HL.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")
  
  colClasses<-rep(NA,ncol(HH))
  colClasses[which(names(HH)=="statistical_rectangle")]<-"character"
  
  HH<-read.table(file.path(OTT_data_folder, "HH.csv"),sep=";",header=TRUE,colClasses = colClasses, encoding = "WINDOWS-1252")
  
  # create TAB output
  TAB<-prep_sel_data(data=list(TR,HH,SL,HL))
  
  #' @description Testing the output from `prep_sel_data` in a data.frame
  expect_s3_class(object = TAB,
                  class = "data.frame"
                  )

  # Convert all columns to vectors for the first rows
  TAB_head_vec <- TAB %>% head() %>% purrr::map(as.vector)
  
  #' @description Testing the first rows of the OTT data.frame output from `prep_sel_data`
  expect_equal(object = TAB_head_vec,
               expected = list(
               # long dput() start ----
                 trip_code = c(3, 3, 3, 3, 3, 3),
                 sampling_type = c("S",
                                   "S", "S", "S", "S", "S"),
                 landing_country = c("FRA", "FRA", "FRA",
                                     "FRA", "FRA", "FRA"),
                 vessel_flag_country = c("FRA", "FRA", "FRA",
                                         "FRA", "FRA", "FRA"),
                 year = c(2023, 2023, 2023, 2023, 2023,
                          2023),
                 project = c("InseR", "InseR", "InseR", "InseR", "InseR",
                             "InseR"),
                 vessel_length = c(14.85, 14.85, 14.85, 14.85, 14.85,
                                   14.85),
                 vessel_power = c(249, 249, 249, 249, 249, 249),
                 vessel_size = c(45,
                                 45, 45, 45, 45, 45),
                 vessel_type = c(1, 1, 1, 1, 1, 1),
                 harbour = c(
                   "Lorient",
                   "Lorient",
                   "Lorient",
                   "Lorient",
                   "Lorient",
                   "Lorient"
                 ),
                 number_of_sets = c(NA,
                                    NA, NA, NA, NA, NA),
                 days_at_sea = c(NA, NA, NA, NA, NA, NA),
                 vessel_identifier = c(
                   "vessel1",
                   "vessel1",
                   "vessel1",
                   "vessel1",
                   "vessel1",
                   "vessel1"
                 ),
                 sampling_country = c("FRA", "FRA",
                                      "FRA", "FRA", "FRA", "FRA"),
                 sampling_method = c(
                   "Observer",
                   "Observer",
                   "Observer",
                   "Observer",
                   "Observer",
                   "Observer"
                 ),
                 departure_date_time = c(NA, NA, NA, NA, NA, NA),
                 return_date_time = c(NA,
                                      NA, NA, NA, NA, NA),
                 gear_identifier = c(1, 1, 1, 1, 1, 1),
                 gear_type = c("OTT", "OTT", "OTT", "OTT", "OTT", "OTT"),
                 sub_gear_identifier = c(1, 1, 1, 1, 1, 1),
                 gear_label = c("STD",
                                "STD", "STD", "STD", "STD", "STD"),
                 buoy_weight_kg = c(NA,
                                    NA, NA, NA, NA, NA),
                 door_type = c(
                   "OSPRET MORGERE",
                   "OSPRET MORGERE",
                   "OSPRET MORGERE",
                   "OSPRET MORGERE",
                   "OSPRET MORGERE",
                   "OSPRET MORGERE"
                 ),
                 entremise_length = c(NA, NA, NA, NA, NA, NA),
                 groundrope_type = c(NA,
                                     NA, NA, NA, NA, NA),
                 headline_cumulative_length = c(NA, NA,
                                                NA, NA, NA, NA),
                 mesh_gauge_back = c(90, 90, 90, 90, 90,
                                     90),
                 mesh_gauge_belly = c(90, 90, 90, 90, 90, 90),
                 mesh_gauge_gor = c(90,
                                    90, 90, 90, 90, 90),
                 selective_device = c(
                   "Grille à langoustine",
                   "Grille à langoustine",
                   "Grille à langoustine",
                   "Grille à langoustine",
                   "Grille à langoustine",
                   "Grille à langoustine"
                 ),
                 station_number = c(3L,
                                    3L, 3L, 3L, 3L, 3L),
                 fishing_validity = c("V", "V", "V",
                                      "V", "V", "V"),
                 aggregation_level = c("H", "H", "H", "H",
                                       "H", "H"),
                 catch_registration = c("All", "All", "All", "All",
                                        "All", "All"),
                 species_registration = c("Par", "Par", "Par",
                                          "Par", "Par", "Par"),
                 date = c(
                   "2021-05-12",
                   "2021-05-12",
                   "2021-05-12",
                   "2021-05-12",
                   "2021-05-12",
                   "2021-05-12"
                 ),
                 time = c("06:30", "06:30", "06:30", "06:30", "06:30", "06:30"),
                 fishing_duration = c(3.75, 3.75, 3.75, 3.75, 3.75, 3.75),
                 pos_start_lat_dec = c(
                   47.5138888888889,
                   47.5138888888889,
                   47.5138888888889,
                   47.5138888888889,
                   47.5138888888889,
                   47.5138888888889
                 ),
                 pos_start_lon_dec = c(
                   -4.04305555555556,
                   -4.04305555555556,
                   -4.04305555555556,
                   -4.04305555555556,
                   -4.04305555555556,
                   -4.04305555555556
                 ),
                 pos_stop_lat_dec = c(
                   47.5583333333333,
                   47.5583333333333,
                   47.5583333333333,
                   47.5583333333333,
                   47.5583333333333,
                   47.5583333333333
                 ),
                 pos_stop_lon_dec = c(
                   -4.19166666666667,
                   -4.19166666666667,
                   -4.19166666666667,
                   -4.19166666666667,
                   -4.19166666666667,
                   -4.19166666666667
                 ),
                 area = c(NA, NA, NA,
                          NA, NA, NA),
                 statistical_rectangle = c("24E5", "24E5", "24E5",
                                           "24E5", "24E5", "24E5"),
                 subpolygon = c(NA, NA, NA, NA, NA,
                                NA),
                 tag_operation = c(NA, NA, NA, NA, NA, NA),
                 diurnal_operation = c("Y",
                                       "Y", "Y", "Y", "Y", "Y"),
                 gear_speed = c(3.5, 3.5, 3.5, 3.5,
                                3.5, 3.5),
                 gear_depth = c(99L, 99L, 99L, 99L, 99L, 99L),
                 sea_state = c(4L, 4L, 4L, 4L, 4L, 4L),
                 wind_force_beaufort = c(4L,
                                         4L, 4L, 4L, 4L, 4L),
                 wind_cardinal_direction = c("Ouest",
                                             "Ouest", "Ouest", "Ouest", "Ouest", "Ouest"),
                 recilinear_operation = c("N",
                                          "N", "N", "N", "N", "N"),
                 seabed_features = c(NA, NA, NA,
                                     NA, NA, NA),
                 sub_gear_position = c("B", "B", "B", "B", "B",
                                       "B"),
                 sorting_start_date_time = c(
                   "2021-05-12 10:25:00",
                   "2021-05-12 10:25:00",
                   "2021-05-12 10:25:00",
                   "2021-05-12 10:25:00",
                   "2021-05-12 10:25:00",
                   "2021-05-12 10:25:00"
                 ),
                 sorting_end_date_time = c(
                   "2021-05-12 12:00:00",
                   "2021-05-12 12:00:00",
                   "2021-05-12 12:00:00",
                   "2021-05-12 12:00:00",
                   "2021-05-12 12:00:00",
                   "2021-05-12 12:00:00"
                 ),
                 catch_weight = c(NA,
                                  NA, NA, NA, NA, NA),
                 discard_weight = c(
                   123.849998474121,
                   123.849998474121,
                   123.849998474121,
                   123.849998474121,
                   123.849998474121,
                   123.849998474121
                 ),
                 coef_discard = c(
                   0.0834880926926171,
                   0.0834880926926171,
                   0.0834880926926171,
                   0.0834880926926171,
                   0.0834880926926171,
                   0.0834880926926171
                 ),
                 species = c(
                   "Lepidorhombus whiffiagonis",
                   "Lepidorhombus whiffiagonis",
                   "Lepidorhombus whiffiagonis",
                   "Lepidorhombus whiffiagonis",
                   "Nephrops norvegicus",
                   "Nephrops norvegicus"
                 ),
                 catch_category = c("LAN", "LAN", "LAN", "LAN", "DIS",
                                    "DIS"),
                 landing_category = c("HUC", "HUC", "HUC", "HUC",
                                      "HUC", "HUC"),
                 commercial_size_category_scale = c(NA, NA,
                                                    NA, NA, "P/G", "P/G"),
                 commercial_size_category = c(
                   NA_character_,
                   NA_character_,
                   NA_character_,
                   NA_character_,
                   NA_character_,
                   NA_character_
                 ),
                 subsampling_category = c(NA, NA, NA, NA,
                                          "Vrac", "Vrac"),
                 sex = c(NA, NA, NA, NA, NA, NA),
                 length_code = c("cm",
                                 "cm", "cm", "cm", "mm", "mm"),
                 subsample_weight = c(1000L,
                                      1000L, 1000L, 1000L, 500L, 500L),
                 coef_subsampling = c(
                   0.0166666666666667,
                   0.0166666666666667,
                   0.0166666666666667,
                   0.0166666666666667,
                   0.416666666666667,
                   0.416666666666667
                 ),
                 sample_weight = c(1000L,
                                   1000L, 1000L, 1000L, 2900L, 2900L),
                 weight = c(60000, 60000,
                            60000, 60000, 1200, 1200),
                 length_class = c(25L, 28L, 31L,
                                  32L, 18L, 19L),
                 number_at_length = c(1L, 1L, 1L, 2L, 1L,
                                      2L),
                 elevated_number_at_length = c(60, 60, 60, 120, 2.4,
                                               4.8),
                 measure_type = c("TL", "TL", "TL", "TL", "CL", "CL"),
                 vessel_name = c(NA, NA, NA, NA, NA, NA),
                 mesh_gauge_codend_mm = c(NA,
                                          NA, NA, NA, NA, NA),
                 water_depth = c(NA, NA, NA, NA, NA,
                                 NA),
                 start_sorting_date_time = c(NA, NA, NA, NA, NA, NA),
                 end_sorting_date_time = c(NA, NA, NA, NA, NA, NA),
                 wind_force = c(NA,
                                NA, NA, NA, NA, NA)
               # long dput() stop ----
               )
  )
  
  # Setup OTB input data
  OTB_data_folder <- system.file("script_origin","Data","Example_OTB_alternate", package = "inser")

  TR <- readr::read_delim(
    file = file.path(OTB_data_folder, "TR.csv"),
    delim = ";",
    escape_double = FALSE,
    locale = readr::locale(encoding = "WINDOWS-1252"),
    trim_ws = TRUE
  )
  HH<-read.table(file.path(OTB_data_folder, "HH.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")#,colClasses = colClasses)
  SL<-read.table(file.path(OTB_data_folder, "SL.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")
  HL<-read.table(file.path(OTB_data_folder, "HL.csv"),sep=";",header=TRUE, encoding = "WINDOWS-1252")
  
  colClasses<-rep(NA,ncol(HH))
  colClasses[which(names(HH)=="statistical_rectangle")]<-"character"
  
  HH<-read.table(file.path(OTB_data_folder, "HH.csv"),sep=";",header=TRUE,colClasses = colClasses, encoding = "WINDOWS-1252")
  
  # create TAB output
  TAB<-prep_sel_data(data=list(TR,HH,SL,HL))
  
  #' @description Testing the output from `prep_sel_data` in a data.frame
  expect_s3_class(object = TAB,
                  class = "data.frame"
                  )

  # Convert all columns to vectors for the first rows
  TAB_head_vec <- TAB %>% head() %>% purrr::map(as.vector)
  
  #' @description Testing the first rows of the OTB data.frame output from `prep_sel_data`
  expect_equal(
    object = TAB_head_vec,
    expected = list(
      # long dput() start ----
      trip_code = c(3, 3, 3, 3, 3, 3),
      sampling_type = c("S",
                        "S", "S", "S", "S", "S"),
      landing_country = c("FRA", "FRA", "FRA",
                          "FRA", "FRA", "FRA"),
      vessel_flag_country = c("FRA", "FRA", "FRA",
                              "FRA", "FRA", "FRA"),
      year = c(2023, 2023, 2023, 2023, 2023,
               2023),
      project = c("InseR", "InseR", "InseR", "InseR", "InseR",
                  "InseR"),
      vessel_length = c(14.85, 14.85, 14.85, 14.85, 14.85,
                        14.85),
      vessel_power = c(249, 249, 249, 249, 249, 249),
      vessel_size = c(45,
                      45, 45, 45, 45, 45),
      vessel_type = c(1, 1, 1, 1, 1, 1),
      harbour = c(
        "Lorient",
        "Lorient",
        "Lorient",
        "Lorient",
        "Lorient",
        "Lorient"
      ),
      number_of_sets = c(NA,
                         NA, NA, NA, NA, NA),
      days_at_sea = c(NA, NA, NA, NA, NA, NA),
      vessel_identifier = c(
        "vessel1",
        "vessel1",
        "vessel1",
        "vessel1",
        "vessel1",
        "vessel1"
      ),
      sampling_country = c("FRA", "FRA",
                           "FRA", "FRA", "FRA", "FRA"),
      sampling_method = c(
        "Observer",
        "Observer",
        "Observer",
        "Observer",
        "Observer",
        "Observer"
      ),
      departure_date_time = c(NA, NA, NA, NA, NA, NA),
      return_date_time = c(NA,
                           NA, NA, NA, NA, NA),
      gear_identifier = c(1, 1, 1, 1, 1, 1),
      gear_type = c("OTB", "OTB", "OTB", "OTB", "OTB", "OTB"),
      sub_gear_identifier = c(1, 1, 1, 1, 1, 1),
      gear_label = c("STD",
                     "STD", "STD", "STD", "STD", "STD"),
      buoy_weight_kg = c(NA,
                         NA, NA, NA, NA, NA),
      door_type = c(
        "OSPRET MORGERE",
        "OSPRET MORGERE",
        "OSPRET MORGERE",
        "OSPRET MORGERE",
        "OSPRET MORGERE",
        "OSPRET MORGERE"
      ),
      entremise_length = c(NA, NA, NA, NA, NA, NA),
      groundrope_type = c(NA,
                          NA, NA, NA, NA, NA),
      headline_cumulative_length = c(NA, NA,
                                     NA, NA, NA, NA),
      mesh_gauge_back = c(90, 90, 90, 90, 90,
                          90),
      mesh_gauge_belly = c(90, 90, 90, 90, 90, 90),
      mesh_gauge_gor = c(90,
                         90, 90, 90, 90, 90),
      selective_device = c(
        "Grille à langoustine",
        "Grille à langoustine",
        "Grille à langoustine",
        "Grille à langoustine",
        "Grille à langoustine",
        "Grille à langoustine"
      ),
      station_number = c(1L,
                         1L, 1L, 1L, 1L, 1L),
      fishing_validity = c("V", "V", "V",
                           "V", "V", "V"),
      aggregation_level = c("H", "H", "H", "H",
                            "H", "H"),
      catch_registration = c("All", "All", "All", "All",
                             "All", "All"),
      species_registration = c("Par", "Par", "Par",
                               "Par", "Par", "Par"),
      date = c(
        "2021-05-12",
        "2021-05-12",
        "2021-05-12",
        "2021-05-12",
        "2021-05-12",
        "2021-05-12"
      ),
      time = c("06:30", "06:30", "06:30", "06:30", "06:30", "06:30"),
      fishing_duration = c(3.75, 3.75, 3.75, 3.75, 3.75, 3.75),
      pos_start_lat_dec = c(
        47.5138888888889,
        47.5138888888889,
        47.5138888888889,
        47.5138888888889,
        47.5138888888889,
        47.5138888888889
      ),
      pos_start_lon_dec = c(
        -4.04305555555556,
        -4.04305555555556,
        -4.04305555555556,
        -4.04305555555556,
        -4.04305555555556,
        -4.04305555555556
      ),
      pos_stop_lat_dec = c(
        47.5583333333333,
        47.5583333333333,
        47.5583333333333,
        47.5583333333333,
        47.5583333333333,
        47.5583333333333
      ),
      pos_stop_lon_dec = c(
        -4.19166666666667,
        -4.19166666666667,
        -4.19166666666667,
        -4.19166666666667,
        -4.19166666666667,
        -4.19166666666667
      ),
      area = c(NA, NA, NA,
               NA, NA, NA),
      statistical_rectangle = c("24E5", "24E5", "24E5",
                                "24E5", "24E5", "24E5"),
      subpolygon = c(NA, NA, NA, NA, NA,
                     NA),
      tag_operation = c(3L, 3L, 3L, 3L, 3L, 3L),
      diurnal_operation = c("Y",
                            "Y", "Y", "Y", "Y", "Y"),
      gear_speed = c(3.5, 3.5, 3.5, 3.5,
                     3.5, 3.5),
      gear_depth = c(99L, 99L, 99L, 99L, 99L, 99L),
      sea_state = c(4L, 4L, 4L, 4L, 4L, 4L),
      wind_force_beaufort = c(4L,
                              4L, 4L, 4L, 4L, 4L),
      wind_cardinal_direction = c("Ouest",
                                  "Ouest", "Ouest", "Ouest", "Ouest", "Ouest"),
      recilinear_operation = c("N",
                               "N", "N", "N", "N", "N"),
      seabed_features = c(NA, NA, NA,
                          NA, NA, NA),
      sub_gear_position = c("B", "B", "B", "B", "B",
                            "B"),
      sorting_start_date_time = c(
        "2021-05-12 10:25:00",
        "2021-05-12 10:25:00",
        "2021-05-12 10:25:00",
        "2021-05-12 10:25:00",
        "2021-05-12 10:25:00",
        "2021-05-12 10:25:00"
      ),
      sorting_end_date_time = c(
        "2021-05-12 12:00:00",
        "2021-05-12 12:00:00",
        "2021-05-12 12:00:00",
        "2021-05-12 12:00:00",
        "2021-05-12 12:00:00",
        "2021-05-12 12:00:00"
      ),
      catch_weight = c(NA,
                       NA, NA, NA, NA, NA),
      discard_weight = c(
        123.849998474121,
        123.849998474121,
        123.849998474121,
        123.849998474121,
        123.849998474121,
        123.849998474121
      ),
      coef_discard = c(
        0.0834880926926171,
        0.0834880926926171,
        0.0834880926926171,
        0.0834880926926171,
        0.0834880926926171,
        0.0834880926926171
      ),
      species = c(
        "Lepidorhombus whiffiagonis",
        "Lepidorhombus whiffiagonis",
        "Lepidorhombus whiffiagonis",
        "Lepidorhombus whiffiagonis",
        "Nephrops norvegicus",
        "Nephrops norvegicus"
      ),
      catch_category = c("LAN", "LAN", "LAN", "LAN", "DIS",
                         "DIS"),
      landing_category = c("HUC", "HUC", "HUC", "HUC",
                           "HUC", "HUC"),
      commercial_size_category_scale = c(NA, NA,
                                         NA, NA, "P/G", "P/G"),
      commercial_size_category = c(
        NA_character_,
        NA_character_,
        NA_character_,
        NA_character_,
        NA_character_,
        NA_character_
      ),
      subsampling_category = c(NA, NA, NA, NA,
                               "Vrac", "Vrac"),
      sex = c(NA, NA, NA, NA, NA, NA),
      length_code = c("cm",
                      "cm", "cm", "cm", "mm", "mm"),
      subsample_weight = c(1000L,
                           1000L, 1000L, 1000L, 500L, 500L),
      coef_subsampling = c(
        0.0166666666666667,
        0.0166666666666667,
        0.0166666666666667,
        0.0166666666666667,
        0.416666666666667,
        0.416666666666667
      ),
      sample_weight = c(1000L,
                        1000L, 1000L, 1000L, 2900L, 2900L),
      weight = c(60000, 60000,
                 60000, 60000, 1200, 1200),
      length_class = c(25L, 28L, 31L,
                       32L, 18L, 19L),
      number_at_length = c(1L, 1L, 1L, 2L, 1L,
                           2L),
      elevated_number_at_length = c(60, 60, 60, 120, 2.4,
                                    4.8),
      measure_type = c("TL", "TL", "TL", "TL", "CL", "CL"),
      vessel_name = c(NA, NA, NA, NA, NA, NA),
      mesh_gauge_codend_mm = c(NA,
                               NA, NA, NA, NA, NA),
      water_depth = c(NA, NA, NA, NA, NA,
                      NA),
      start_sorting_date_time = c(NA, NA, NA, NA, NA, NA),
      end_sorting_date_time = c(NA, NA, NA, NA, NA, NA),
      wind_force = c(NA,
                     NA, NA, NA, NA, NA)
      # long dput() stop ----
    )
  )

})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_prep_sel_data.Rmd",
  vignette_name = "Selectivity data",
  check = FALSE,
  overwrite = TRUE)
```

